==============================================
SpaceShooter02 - Dev Notes
==============================================

Unreal Engine 5 project based on:
https://github.com/RSkala/SpaceShooter01
* Twin Stick shooter built in Unity C#

==============================================
Source Assets:

Space Shooter Asset Pack by Gustavo Vituri
https://gvituri.itch.io/space-shooter

Location in Project:
* Assets-Source/SpaceShooterAssets

==============================================
Asset Naming Convention References:
* https://dev.epicgames.com/documentation/en-us/unreal-engine/recommended-asset-naming-conventions-in-unreal-engine-projects
* https://unrealdirective.com/resources/asset-naming-conventions
* https://github.com/Allar/ue5-style-guide

Texture: T_ or T2D_  -- Note: I usually leave the Texture the same as the imported asset
Sprite: SPR_

==============================================
Pixels Per Unit

* Project Settings -> Editor -> Paper2D - Import -> Default Pixels Per Unreal Unit

I selected 0.08PPU for this project.

My reasoning for this is as follows:
* The asset pack I am using has the standard sprite size of 8x8.
* 1 Unreal Unit = 100cm (0.0328ft) 
* 100 Unreal Units = 100cm = 1m (3.328ft)
* I prefer to have my 2D pixel art characters to be 1m = 100cm = 100UU
* In general, it is a good idea to have decently-sized pixel art characters, as the CharacterMovementComponent expects the character to be "reasonable" height (i.e. human-sized)
* Note: I likely will not be using Characters or CharacterMovementComponent in this project, but I wanted to define a "standard" PPU.

Formula for Calculating PPU:
* Base-Character-Pixel-Height / 100
  * Using 100 for 100UU or 100cm or 1m

PPU Calculation for Project:
* Base Character Size:    8x8 pixels
* Base Character Height:  8px
* 8px / 100cm = 0.08px/cm = 0.08px/UU
* 0.08 PPU

This means that a character with a height of 8 pixels will have a height of 100m or 1m.

==============================================
Project Settings for 2D Pixel Art

Project Settings -> Engine -> Rendering -> Default Settings:
* Bloom: OFF
* Auto Exposure: OFF
* Auto Exposure: Manual
* Auto Exposure Bias: 0.0
* Motion Blur: OFF
* Anti-Aliasing Method: None

==============================================
Post Process Settings

The Post Process settings are set up in a PostProcessVolume in your Level.

Reason this needs to be done:
* A level has its own "hidden" PostProcessVolume with these settings enabled and set to some value by default. Creating your own PostProcessVolume in a Level will override these "hidden" default PostProcessVolume settings. Unreal still applies default post process settings that MUST be manually disabled in a level PostProcessVolume


Add a PostProcessVolume to Your Game Map:
* Quick Add -> Visual Effects -> PostProcessVolume
  * Set Transform Location to (0,0,0), although this really shouldn't matter
    * Note: The position shouldn't really matter, so long Infinite Extent (Unbound) is set to TRUE

Settings in PostProcesVolume's Details Panel:

* Post Process Volume Settings -> Infinite Extent (Unbound): TRUE
  * This means the setting will be applied no matter where the camera is. If unchecked, will only apply when camera is inside the box.

* Lens -> Bloom -> Threshold: TRUE, set to 1.0
  * This limits the glowing effect around bright elements

* Lens -> Exposure -> Exposure Compensation: TRUE, set to 0.0
  * Removes the slightly brightened and corrected effect

* Lens -> Exposure -> MinEV100: TRUE, set to 0.0
* Lens -> Exposure -> MaxEV100: TRUE, set to 0.0
  * These specify the auto-exposure effect range. Auto-Exposure can and should be disabled in Project Settings -> Engine -> Rendering -> Default Settings
  * When Auto-Exposure is disabled, these should have no effect, but we should still disable them just in case.

* Lens -> Image Effects -> Vignette Intensity: TRUE, set to 0.0
  * This eliminates the elements that make the edges of the screen slightly darker

* Color Grading -> Misc -> Expand Gamut: TRUE, set to 0.0
* Color Grading -> Misc -> Tone Curve Amount: TRUE, set to 0.0
  * These two settings make the sprites much brighter than they are supposed to be and therefore should be set to 0

==============================================
Texture Settings for 2D Pixel Art

Default way of applying Texture Settings for 2D:
* Right-click Texture -> Sprite Actions -> Apply Paper2D Texture Settings
  * Note that this only applies the settings in the Paper2D Import project settings, and therefore not all of the settings below will be set.

While Texture asset is open, in Details, ensure the following settings are set:

* Level of Detail -> Mip Gen Settings: NoMipMaps
* Level of Detail -> Texture Group: 2D Pixels (unfiltered)
* Compression -> Compression Settings: UserInterface2D (RGBA)
* Texture -> sRGB: True
* Texture -> Advanced -> Filter: Nearest

-------
NOTE:
* This can be changed using a "Scripted Asset Actions" tool, so you don't have to do all of the above manually every single time.
* Source:
  * https://www.youtube.com/watch?v=_sgyZ2dsUV0

==============================================
Editor Viewport Settings

* Upper-left of Viewport -> Viewport Options -> 
  * Realtime:  FALSE

* Projection Settings:
  * Right (Orthographic, looking down the "Right" / Y axis towards the origin)
    * This means our game will be played in the XZ plane (X-right, Z-up)

* View Mode:
  * Unlit

==============================================
Orthographic Width

This is the width of the camera view in Unreal Units
So, a Ortho Width of 1000 is exactly 1000 Unreal Units = 1000cm = 10m
This means that exactly 10 ship sprites in this game will across the screen from edge to edge.

If the Aspect Ratio is set to 16:9 (1.777778), then the screen height will be:
1000 / 1.777778 ~ 562

Therefore, the screen orthographic viewport size will be:
1000 x 562

However, this is way too small for this game.
Using 3840, so the size will be:
3840 x 2160 (i.e. 4K, although that doesn't really matter)

==============================================
Note Regarding Orthographic Camera
* If Orthographic Camera is enabled, then Camera Lag DOES NOT work.
* It seems you MUST have a Perspective Camera in order for Camera Lag to work.
* This seems like an Unreal Engine bug.

==============================================
Player Input:

NOTES:
* Note that I separated movement input between keyboard and gamepad. I did this intentionally so I could debug inputs more easily.
* That is:

  void KeyboardMoveTriggered(const struct FInputActionValue& InputActionValue);
  void KeyboardMoveCompleted(const struct FInputActionValue& InputActionValue);

  void GamepadMoveTriggered(const struct FInputActionValue& InputActionValue);
  void GamepadMoveCompleted(const struct FInputActionValue& InputActionValue);

* I implemented this first in the PlayerShipPawn class directly, so it would be quicker to implement. Once movement and general gameplay input is working sufficiently, I plan on moving this over to a custom PlayerController subclass.

---------------------------------------------------

Blueprint Setup:

---------------------------------------------------
Thumbstick Input:

Input Action:
* Value Type: Axis2D (Vector2D)
* Modifier: Dead Zone
  * Default values of [0.2, 1.0] works well

Input Mapping Context:
* After adding the InputAction:
* Assign Gamepad Left Thumbstick X-Axis
  * Default values are fine
* Assign Gamepad Left Thumbstick Y-Axis
  * Modifier: Swizzle Input Axis Values
* Note that the DeadZone modifier is "inherited" from the InputAction and cannot be edited here

---------------------------------------------------
Keyboard Input for Movement (WASD)

Input Action:
* Value Type: Axis2D (Vector2D)
* No other settings need to be changed

Input Mapping Context:
* After adding the InputAction:
* D = Right / +X axis => Default
* A = Left  / -X axis => Modifier: Negate
* W = Up    / +Y axis => Modifier: Swizzle Input Axis Values YXZ
* S = Down  / -Y axis => Modifier: Negate, Swizzle Input Axis Values YXZ

---------------------------------------------------


==============================================
Enemy Sprites / Facing / Rotation

The enemy sprites are in the Texture SpaceShooterAssetPack_Ships
The player ships were built facing UP.
The enemy ships were built facing DOWN.

I calculate "facing" all facing directions using the World Up (+Z axis)

So, when building the enemy Blueprints, the Sprite Component needs to be rotated 180 degrees around the Y axis
Note: Y axis rotations in Unreal Engine is the "Pitch"

==============================================
TODO:
* Extracting Sprites, Extracting Single Sprite
* Process
* Pivot

==============================================
Projectiles

When spawning projectiles dynamically (i.e. using SpawnActor()), I first just spawned them at the player position.
This caused the projectile to immediately "collide" with the player.
As a quick test, I added the player ship as the Instigator, immediately after spawning. However, on collision, the Instigator (using GetInstigator())was not always filled out (meaning, it was nullptr).
My assumption is that the collision would happen in the instant in between the spawn and setting the instigator:

AProjectileBase* FiredProjectile = World->SpawnActor<AProjectileBase>(ProjectileClass, PlayerShipPosition, PlayerShipRotation);
FiredProjectile->SetInstigator(this);

As a test, I tried using SpawnActorDeferred(), which takes in the Instigator, and then I call FinishSpawning().
This seems to have worked:

AProjectileBase* FiredProjectile = World->SpawnActorDeferred<AProjectileBase>(
  ProjectileClass,
  ProjectileTransform,
  this,
  this,
  ESpawnActorCollisionHandlingMethod::AlwaysSpawn,
  ESpawnActorScaleMethod::MultiplyWithRoot);
FiredProjectile->FinishSpawning(ProjectileTransform);

NOTE:
* This was just more of a test/experiment. I plan on adding pooling, which will prevent this, but I still do not want projectiles fired by the player to collide with the player.
* I will experiment with collision settings to prevent this (that is, as opposed to allowing the collison and checking if OtherActor != GetInstigator())

UPDATE:
I can use FActorSpawnParameters to set the instigator
Tested and works:

FActorSpawnParameters ProjectileSpawnParameters;
ProjectileSpawnParameters.Name = TEXT("Projectile_");
ProjectileSpawnParameters.Instigator = this;
ProjectileSpawnParameters.NameMode = FActorSpawnParameters::ESpawnActorNameMode::Requested;
ProjectileSpawnParameters.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

AProjectileBase* FiredProjectile = World->SpawnActor<AProjectileBase>(ProjectileClass, PlayerShipPosition, PlayerShipRotation, ProjectileSpawnParameters);

------------------------------------------
Custom Collision Channels:
* Project Settings -> Engine -> Collision:
  * Object Channels
  * Trace Channels

Adding an Object or Trace Channel will modify Config/DefaultEngine.ini in:

[/Script/Engine.CollisionProfile]

------------------------------------------

==============================================
Gamepad Right-Thumbstick Aiming

* On gamepads, the joystick Y-Axis UP is NEGATIVE and the joystick Y-Axis DOWN is POSITIVE.

Therefore, in addition to Swizzle Axis Values you MUST also add the NEGATE modifier.
That is, if you're expecting Y-Axis UP to be Positive (which I do, as that is what I used to calculate rotations).

I've been using the Movement and Aiming in 3D, but I might be able to use 2D:

float Cross2D = FVector2D::CrossProduct(FVector2D::UnitY(), MovementDirection);
UE_LOG(LogTemp, Warning, TEXT("Movement - 2D Cross Product: %f"), Cross2D);

https://stackoverflow.com/questions/22571740/what-is-the-geometry-meaning-of-2d-cross-product

==============================================
Custom Mouse Cursor / Crosshair

Software Cursors:
* This is assuming the cursor texture and sprite have already been set up
* You need a Widget Blueprint in order to use custom software mouse cursors
* After the widget blueprint is setup, it needs to be changed in Project Settings


--- Create the Widget Blueprint ---

* Create the Widget Blueprint:
  * Content Browser -> Right-click -> User Interface -> Widget Blueprint
    * Select "User Widget"  (naming convention: WBP_<my-widget>)
* Open the widget and add the following classes from the Palette in the following hierarchy:

WBP_MouseCursor
 |- Canvas Panel
     |- Image

* Select the top level n the Hierarchy (e.g. WBP_MouseCursor)
  * In the Designer window, change "Fill Screen" to Desired On Screen

* Select the Image in the Hierarchy
  * Details -> Appearance -> Brush -> Image
    * Select your crosshair/cursor sprite
  * Details -> Slot (Canvas Panel Slot)
    * Anchors: In the drop-down, select "Center" (may need to hold Ctrl+Shift as well)
    * Size X, Size Y:  
      * Adjust these to make sense for your game

--- Add Your Custom Mouse Cursor to the Project ---

Project Settings:
Edit -> Project Settings -> Engine -> User Interface -> Software Cursors
* Click + to Add
  * Type (1st drop-down): Default
    * "Default" changes the "default" mouse cursor (i.e. the cursor you're almost always looking at)
  * Set type to Default for this demo
  * Class (2nd drop-down): Set to your cursor Widget Blueprint (e.g. WBP_MouseCursor)

--------------------
Notes regarding software cursors:
* The mouse cursor / crosshair does not change size when resizing the screen
* They are limited by frame rate, so if your framerate is low, the mouse cursor will be choppy
* Software Cursors were maybe be limited by windows scaling (so different people would have different sizes)
* Hardware cursors are supposed to be the RIGHT way to handle cursors, but this works for now.
--------------------

==============================================
Hiding / Showing the Mouse Cursor

In theory, all you should do is the following:
PlayerController->SetShowMouseCursor(bCursorVisible);

However, I found the cursor would not refresh (hidden or unhidden) unless the mouse was moved slightly.
So, I needed to figure out how to "refresh" the mouse cursor.
My debugging led me to FSceneViewport::OnCursorQuery
But I couldn't figure out how to "query" the viewport.
After some googling, I was able to come up with this, which works:


void APlayerShipPawn::SetMouseCursorVisiblityFromInput(APlayerController* const PlayerController, bool bCursorVisible)
{
  if (PlayerController != nullptr)
  {
    PlayerController->SetShowMouseCursor(bCursorVisible);
  }

  // Force the SlateApplication to refresh the mouse cursor, otherwise it will not change until there is some mouse movement
  FSlateApplication& SlateApplication = FSlateApplication::Get();
  SlateApplication.SetAllUserFocusToGameViewport(); // TODO: Is this necessary?
  SlateApplication.QueryCursor();
}

In order to use FSlateApplication, you must edit the .Build.cs file and comment or add this:
PrivateDependencyModuleNames.AddRange(new string[] { “Slate”, “SlateCore” });

If you don't, you will likely get build errors.

Source:
https://forums.unrealengine.com/t/mouse-cursor-not-changing-until-moved/290523/15

---------------------------------------
Part 2:

Once I had the mouse cursor hiding/unhiding properly, there was an issue where the mouse cursor wouldnt reappear until I clicked a mouse button.
This makes sense, as I didn't map "Mouse Move" to anything yet.
Once I created an Input Action, with Axis2D, and successfully mapped and set its binding, there was a problem where the MouseMove doesn't register anything UNLESS I hold down a mouse button

This is how it was bound:
EnhancedInputComponent->BindAction(InputActionMouseMove, ETriggerEvent::Triggered, this, &ThisClass::MouseMove);

https://forums.unrealengine.com/t/enhanced-input-system-mouse-xy-2d-axis-only-registering-input-while-holding-down-a-mouse-key/1311170

https://forums.unrealengine.com/t/enhanced-input-system-mouse-xy-2d-axis-only-registering-input-while-holding-down-a-mouse-key/1311170/10?u=rskala
* Note: I tried this fix, which uses the Legacy Input System, and the same thing occurs.

---------------------------------------------------
I'll have to leave this as a "known issue", as it will be a large amount of work to work around, and it will be very seldom when someone is switching between gamepad and mouse controls anyways.

---------------------------------------------------
For reference, this is how Legacy Input works:
Set up in Project Settings -> Engine -> Input -> Axis Mappings

Then in SetupPlayerInputComponent():
  // Bind Legacy Input
  UInputSettings* InputSettings = UInputSettings::GetInputSettings();
  if (InputSettings != nullptr)
  {
    TArray<FInputAxisKeyMapping> AxisMappings;
    InputSettings->GetAxisMappingByName(FName("MouseMove"), AxisMappings);
    PlayerInputComponent->BindAxis("MouseMove", this, &ThisClass::LegacyMouseMove);
  }


==============================================
Enemy Spawning

For simplicity, I created AEnemySpawner as a subclass of AActor.
This way, I could access the Tick function.
AEnemySpawer is created in ASpaceShooterGameState, in BeginPlay()

Other possibilities:

UObject Subclass:
* e.g. UEnemySpawner
* Still could create in the gamestate and pass in DeltaTime during it's Tick()

World Subsystem or TickableWorldSubsystem
* e.g. UEnemySpawnerTickableWorldSubsystem
* Advantages:
  * World Subsystems are tied to the life of the World (like the GameState)
  * Can move code out of the game state
* Disadvantage:
  * I would likely need to create a tool to see the Enemy Spawner values in the editor

==============================================
Explosion Sprites / Flipbooks

Cannot set looping or handle animend callbacks from the UFlipBook.
Can only do this in the UFlipbookComponent

It is also not accessible via the Details window:

  /** Whether the flipbook should loop when it reaches the end, or stop */
  UPROPERTY()
  uint32 bLooping:1;

Animation Finished:
  /** Event called whenever a non-looping flipbook finishes playing (either reaching the beginning or the end, depending on the play direction) */
  UPROPERTY(BlueprintAssignable)
  FFlipbookFinishedPlaySignature OnFinishedPlaying;

So I will need to create a Blueprint with components for the explosions.

I considered adding PaperZD for this purpose but it is overkill, as you need to create AnimationSource and AnimationSequences.
I won't really be switching animations during the game, so I won't need PaperZD yet.
While it is overkill for now, it is a possibility. The PaperZDAnimBP can receive animation notifies and handle when an animation finishes.

-----------------------------------------------
In the Explosion's PaperFlipbookComponent:

...
ExplosionFlipbookComp->SetLooping(false);
...
ExplosionFlipbookComp->OnFinishedPlaying.AddUniqueDynamic(this, &ThisClass::OnExplosionAnimationFinished);

==============================================
Boundaries

* Using a generic White square sprite
* Stretch to create the "Border" around the level
* Mobiity: Static
* Collision Preset: BlockAll
* TODO: Create an ABorderBase class with a BoxComponent for collision

Use a LineTrace for collision.
* This Linetrace "distance" will need to be manually adjusted

----------------------------------------------------------
LineTrace code:

const float TraceLineLength = 1000.0f;
const FVector& TraceStartPos = GetActorLocation();
const FVector& TraceEndPos = GetActorLocation() + FVector(AimingDirection.X, 0.0f, AimingDirection.Y) * TraceLineLength;

DrawDebugLine(World, TraceStartPos, TraceEndPos, FColor::Cyan);

TArray<FHitResult> HitResults;
FCollisionObjectQueryParams ObjectQueryParams(FCollisionObjectQueryParams::InitType::AllStaticObjects);

bool bLineTraceSuccess =
  World->LineTraceMultiByObjectType(
    HitResults,
    TraceStartPos,
    TraceEndPos,
    ObjectQueryParams);

if (bLineTraceSuccess)
{
  if (HitResults.Num() > 0)
  {
    const FHitResult& HitResult = HitResults[0];
    UE_LOG(LogTemp, Warning, TEXT("----------------------------"));
    UE_LOG(LogTemp, Warning, TEXT("HitResult.ImpactPoint:      %s"), *HitResult.ImpactPoint.ToString());
    UE_LOG(LogTemp, Warning, TEXT("HitResult.ImpactNormal:     %s"), *HitResult.ImpactNormal.ToString());
    UE_LOG(LogTemp, Warning, TEXT("HitResult.Normal:           %s"), *HitResult.Normal.ToString());
    UE_LOG(LogTemp, Warning, TEXT("HitResult.Distance:         %f"), HitResult.Distance);
    UE_LOG(LogTemp, Warning, TEXT("HitResult.PenetrationDepth: %f"), HitResult.PenetrationDepth);
    UE_LOG(LogTemp, Warning, TEXT("HitResult.bBlockingHit:     %d"), HitResult.bBlockingHit);

    // Draw reflection vector
    FVector ReflectionVector = FMath::GetReflectionVector(FVector(AimingDirection.X, 0.0f, AimingDirection.Y), HitResult.ImpactNormal);
    FVector ReflectEndPos = HitResult.ImpactPoint + ReflectionVector * 500.0f;
    DrawDebugLine(
      World,
      HitResult.ImpactPoint,
      ReflectEndPos,
      FColor::Green);
  }
}

----------------------------------------------------------

==============================================
Particles

Player Explosion Particle

-----------------------------
Using Niagara in the Project
-----------------------------

In order to use Niagara in C++, you must add "Niagara" to your project dependencies, e.g.

PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "Paper2D", "Niagara" });

Note that you DON'T need this if you're not using Niagara in C++ (i.e. only in Blueprints)


---------------------
Using Niagara in C++
---------------------

#include "NiagaraFunctionLibrary.h"
#include "NiagaraComponent.h"

  UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "PlayerShipPawn|Visual")
  TObjectPtr<class UNiagaraSystem> PlayerExplosionEffect;

  // Play explosion effect
  if (PlayerExplosionEffect != nullptr && PlayerExplosionEffect->IsValid())
  {
    UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), PlayerExplosionEffect.Get(), GetActorLocation());
  }

/Script/Niagara.NiagaraSystem'/Game/FX/FXS_TestExplosion_001.FXS_TestExplosion_001'

Source:
https://dev.epicgames.com/community/learning/tutorials/Gx5j/using-niagara-in-c

==============================================
MODULES

Editor Build Module

Error when building project:
Unable to instantiate module 'UnrealEd': Unable to instantiate UnrealEd module for non-editor targets.
(referenced via Target -> SpaceShooter02.Build.cs -> Blutility.Build.cs -> MainFrame.Build.cs -> Documentation.Build.cs)

This is due to having Blutility as a dependency in the Game module.
So, I need to create an Editor module and move editor-only classes there.

------------------------------------------
Sources:
https://unrealcommunity.wiki/creating-an-editor-module-x64nt5g3

https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-modules?application_version=5.4

https://www.youtube.com/watch?v=DqqQ_wiWYOw

https://www.youtube.com/watch?v=wJquw_-X4YQ

-------------------------------------------

SpaceeShooter02.Target.cs:

    // Apparently, we do not need to check for editor in more recent UE versions
    // If I do, I get errors when generated the VS project files from the uproject
    // https://forums.unrealengine.com/t/what-happend-to-targetinfo-target-in-4-19/106118/11
    //if (Target.Type == TargetType.Editor)
    //{
    //  ExtraModuleNames.AddRange( 
    //    new string[]
    //    {
    //      "SpaceShooter02Editor"
    //    });
    //}

--------------------------------------------
After moving the Blutility Dependency out of the Game module and into a new Editor module (and therefore needing to move the AssetAction class over as well), the packaging succeeded.


==============================================
BUILDS

To create a build:

* Click Platforms button
  * Windows -> Package Project

TODO:
* Reduce packaged project sizes

Resources:
https://docs.unrealengine.com/4.27/en-US/TestingAndOptimization/PerformanceAndProfiling/ReducingPackageSize/
https://dev.epicgames.com/documentation/en-us/unreal-engine/testing-and-optimizing-your-content?application_version=5.4
https://www.youtube.com/watch?v=f9hMB_50B5o
https://www.reddit.com/r/unrealengine/comments/1bofih5/how_to_reduce_package_size_for_unreal_engine_game/
https://cobracode.notion.site/How-to-reduce-Package-Size-for-Unreal-Engine-Game-Builds-7993544e050041f9800512acd3500cfc

==============================================
PERSPECTIVE / ORTHOGRAPHIC CAMERAS

I may change the camera projection mode to Perspective for a few reasons:
* Camera Lag doesn't work in Orthographic
* Can add "layers" to the background "stars" sprites to give a parallax effect.

Settings for Perspective:
* PlayerShip -> CameraComp -> Camera Settings:
  * Projection Mode: Perspective
  * Field Of View: (TBD, but 115 - 135 degrees seem like a good place to start)
* PlayerShip -> SpringArmComp -> Lag
  * Enable Camera Lag: TRUE
  * Enable Camera Rotation Lag: FALSE (default)
  * Draw Debug Lag Markers: TRUE
  * Camera Lag Speed: 8.0f (TBD)
* PlayerShip -> SpringArmComp -> Camera
  * Target Arm Length: (TBD, currently 1000. Will depend on Camera FOV).

Note on Perspective:
* I need to be very conscious now that the player and all enemies are at Y-position 0, so they all appear the same distance from the camera.
* I can either adjust the SpringArm's TargetArm Length or the Perspective Field of View.

Note on Camera Lag:
* The LOWER the number, the SLOWER the camera moves back to its look-at position.

AIMING BUG AFTER SETTING PERSPECTIVE PROJECTION:
* When I changed to Perspective Projection, the Mouse aiming is broken (always fires backwards).
* This only seems to occur while MOVING. If not moving, mouse aiming works.
* Update: This is due to the Camera Lag. If Camera Lag is enabled (in Perspective Projection), then the bullets fire backwards from the player ship, IF the player is MOVING.


==============================================
