Notes on Collisions / Setting up the level boundaries


Boundaries

Using T_White16px.png

Collisions:
Need OnComponentHit

Was not working unless the collision was the ROOT.
Need to enable physics
Need to disable gravity

* Simulation Generates Hit Events
  * C++ version:  SetNotifyRigidBodyCollision()
* Simulate Physics
* 
* Blocking Volumes / Blocking Sprites
  * Mobility: Static
    * If this is set to Movable, then the ship and the bullets will "push" the blocking objects

In order for me to use OnComponentHit, I will have to rebuild all of the Player and Enemy Blueprints.
Note: The player already has a SphereComp as its root

Or, I can use:
UKismetSystemLibrary::LineTraceSingleForObjects
...
World->LineTraceSingleByObjectType
UWorld::LineTraceSingleByObjectType
* Note that there are multiple functions here for this:
  * LineTraceTestByObjectType
  * LineTraceSingleByObjectType
  * LineTraceMultiByObjectType


NOTE:
When I enabled physics and such on the ship, this warning popped up:
Invalid Simulate Options: Body (BP_PlayerShipPawn_C_0.SphereComp) is set to simulate physics but Collision Enabled is incompatible
I have mine set to QueryOnly.
This was set to the Default, which is OverlapAllDynamic Preset, which sets CollisionEnabled to CollisionEnabled_QueryOnly
Changing to Collision Preset: Pawn, which sets CollisionEnabled to CollisionEnabled_QueryAndPhysics

Debugging:
AActor::NotifyHit is called when I cross the BlockingVolume I added to the level.
bSelfMoved = true... will this affect whether the OnComponentHit is called???
ReceiveHit() is then called

THIS SEEMS TO HAVE WORKED:
APlayerShipPawn::OnCollisionHit is called!

It would probably be a good idea to set my own custom collision channels

NOTE:
OnCollisionHit is ONLY when I set the player ship's collision response for WorldStatic to Block
The BlockingVolume is set to CollisionPreset InvisibleWall, which sets everything to Block.

Settings needed on the Sphere Component (collision)

SphereComp->SetSimulatePhysics(true); // This needs to be enabled in order to use "OnComponentHit"
SphereComp->SetNotifyRigidBodyCollision(true); // Set "Simulation Generates Hit Events"
SphereComp->SetEnableGravity(false); // Gravity must be disabled after enabling "SetSimulatePhysics", otherwise the ship will "fall" (-Z)
SphereComp->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);


I was having issue when the player would cross the blocking volume, it would get stuck and "slow down" through it.
All I really wanted was the collision "hit", so I can get a collision position and normal.
This was getting out of hand, so I will likely switch to using the LineTrace

--------------------------------------------------------------
Sources:
https://www.reddit.com/r/unrealengine/comments/bc06a6/cant_get_on_component_hit_to_work/

This Post:

I had a similar issue myself recently, and found the problem could not be fixed in any way I tried other than making the item I wanted to check for collisions as the root of the object. I ended up swicthing to line traces after. There's probably a better solution but nothing I could find on forums or anywhere seemed to help.

NOTE: 
the SphereComp (collision) IS the root of my object

----------------------------------------------------------------


TEST USING A LINE TRACE:

Line Trace Usage:

  if (UWorld* World = GetWorld())
  {
    const float TraceLineLength = 1000.0f;
    const FVector& TraceStartPos = GetActorLocation();
    const FVector& TraceEndPos = GetActorLocation() + FVector(MovementDirection.X, 0.0f, MovementDirection.Y) * TraceLineLength;

    DrawDebugLine(
      World,
      TraceStartPos,
      TraceEndPos,
      FColor::Cyan);

    TArray<FHitResult> HitResults;
    FCollisionQueryParams TraceParams(SCENE_QUERY_STAT(WaterImmersionDepthTrace), true);
    FCollisionObjectQueryParams ObjectQueryParams(FCollisionObjectQueryParams::InitType::AllStaticObjects);

    bool bLineTraceSuccess = World->LineTraceMultiByObjectType(HitResults, TraceStartPos, TraceEndPos, ObjectQueryParams);
    if (bLineTraceSuccess)
    {
      UE_LOG(LogTemp, Warning, TEXT("HitResults: %d"), HitResults.Num());
    }

    //World->LineTraceSingleByObjectType()
  }

==============================================


Handling OnCollisionHit:

	UFUNCTION()
	void OnCollisionOverlap(
		UPrimitiveComponent* OverlappedComponent,
		AActor* OtherActor,
		UPrimitiveComponent* OtherComp,
		int32 OtherBodyIndex,
		bool bFromSweep,
		const FHitResult& SweepResult);

	UFUNCTION()
	void OnCollisionHit(
		UPrimitiveComponent* HitComponent,
		AActor* OtherActor,
		UPrimitiveComponent* OtherComp,
		FVector NormalImpulse,
		const FHitResult& Hit);

Subscribe to the delegate:
SphereComp->OnComponentHit.AddUniqueDynamic(this, &ThisClass::OnCollisionHit);


==============================================

Drawing Debug Objects:

#include "DrawDebugHelpers.h"

		const float TraceLineLength = 1000.0f;
		const FVector& TraceStartPos = GetActorLocation();
		const FVector& TraceEndPos = GetActorLocation() + FVector(MovementDirection.X, 0.0f, MovementDirection.Y) * TraceLineLength;

		DrawDebugLine(
			World,
			TraceStartPos,
			TraceEndPos,
			FColor::Cyan);

		DrawDebugSphere(GetWorld(), SweepResult.ImpactPoint, 100.0f, 50, FColor::Magenta, true, -1.0f, 1, 10.0f);


==============================================

More Notes on Collision Hit / Impact Points / Impact Normals

---------------
OnComponentHit
---------------

In order to use OnComponentHit, you do NOT need to enable physics simulation.
However, there are specific things that MUST be set up in order to capture collision Hit:

* A "Hit" is a BLOCKING response. In other words, BOTH actors must BLOCK each other
* CollionEnabled MUST be "Query and Probe" OR "Probe Only" (Also) (The "Hit" is a probing action) (Also "Collision Enabled", I think)
* If the collision volume is NOT the Root Component, the ComponentHit will NOT work for an actor without a volume as the root component.
* Since a "Hit" is a Blocking respose, the actors will STOP moving once they collide.

I originally had enemies and projectiles have their collision volumes NOT the root, so my OnCollisionHit callbacks were NOT getting called.
Once I changed them so the collision volumes were the RootComponent, then OnCollisionHit was called (after setting the correct CollisionEnabled and Responses of course).

-------------------------------------------
Getting Impact Info Without OnComponentHit
-------------------------------------------

When moving an actor manually, that is, using:
AddActorWorldOffset()
SetActorLocation()
SetWorldLocation() (for Components)

You do NOT need to use OnComponentHit in order to get HitResults.
You can actually do this in OnComponentOverlap (so they do not need to be set to Block).
But you need to enable sweep when calling those functions:

FHitResult SweepHitResult;
SetActorLocation(NewProjectilePosition, true, &SweepHitResult, ETeleportType::None);

You can check the return value of those functions to see if movement occurred (true = movement occurred).
The SweepHitResult will contain the Location/ImpactPoint as well as the Normal/ImpactNormal.

Also, in your OnComponentBeginOverlap callback, 

bool bFromSweep will be true
const FHitResult& SweepResult will have valid data.

Using this, we can spawn impact particles or "reflect" bullets and such.

For my purposes, using Overlaps and Sweeps/Probes is the best way.



==============================================
